# Reload Path to ensure scoop is available in the current session
$env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")

$scoopExecutable = Join-Path $env:USERPROFILE "scoop\shims\scoop.ps1"

Write-Host "Fetching list of currently installed Scoop packages..."
try {
    $installedScoopJson = & $scoopExecutable export | ConvertFrom-Json -ErrorAction Stop
}
catch {
    Write-Error "Failed to get installed packages from Scoop. Error: $_"
    return
}

$installedApps = if ($null -ne $installedScoopJson.apps) { $installedScoopJson.apps } else { @() }

# Create a HashSet for fast, case-insensitive lookups of full 'bucket/package' identifiers.
$installedFullNames = [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase)

# Populate the HashSet with data from the 'scoop export' command.
foreach ($app in $installedApps) {
    # Add the full 'bucket/name' identifier (e.g., "main/7zip")
    [void]$installedFullNames.Add("$($app.Source)/$($app.Name)")
}

# Install packages defined in the YAML file.
{{- $packages := joinPath .chezmoi.sourceDir ".data/packages.yaml" | include | fromYaml -}}

{{- range $packages }}
{{- if hasKey . "scoop" }}
$packageName = '{{ .name }}'
$scoopIdentifier = '{{ .scoop }}'

if (-not $installedFullNames.Contains($scoopIdentifier)) {
    & $scoopExecutable install $scoopIdentifier
}
{{- end -}}
{{- end }}
