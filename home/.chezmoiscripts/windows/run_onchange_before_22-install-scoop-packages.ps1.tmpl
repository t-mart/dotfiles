# Reload Path
$env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")

$scoopExecutable = Join-Path $env:USERPROFILE scoop\shims\scoop.ps1

Write-Host "Fetching list of currently installed Scoop packages..."
$installedScoopJson = & $scoopExecutable export | ConvertFrom-Json -ErrorAction Stop
$installedApps = if ($null -ne $installedScoopJson.apps) { $installedScoopJson.apps } else { @() }

# Create HashSets for fast lookups. Using OrdinalIgnoreCase for case-insensitive matching.
$installedNames = [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase)
$installedFullNames = [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase)

# Populate the HashSets with data from the 'scoop export' command.
foreach ($app in $installedApps) {
    # Add just the package name (e.g., "7zip")
    [void]$installedNames.Add($app.Name)
    # Add the full 'bucket/name' identifier (e.g., "main/7zip")
    [void]$installedFullNames.Add("$($app.Source)/$($app.Name)")
}

# Install packages
{{- $packages := joinPath .chezmoi.sourceDir ".data/packages.yaml" | include | fromYaml -}}
{{- range $packages -}}
{{- if hasKey . "scoop" }}
$packageToCheck = '{{ .scoop }}'
$isInstalled = $false

# Check if the package name from your config contains a slash (e.g., 'main/7zip')
if ($packageToCheck.Contains('/')) {
    # If it does, we check against the full 'bucket/name' list.
    if ($installedFullNames.Contains($packageToCheck)) {
        $isInstalled = $true
    }
} else {
    # Otherwise, we check against the simple name list.
    if ($installedNames.Contains($packageToCheck)) {
        $isInstalled = $true
    }
}

if (-not $isInstalled) {
    Write-Host "Scoop: '$packageToCheck' not found, attempting to install..."
    & $scoopExecutable install $packageToCheck
}
{{- end -}}
{{- end }}
